__script__ = "Cinema Experience"
__scriptID__ = "script.cinema.experience"
###########################################################
"""
    Video Playlist Module:
    - Assembles Video Playlist based on user settings
    - When playlist complete, calls xbmcscript_trivia.py to perform trivia and start playlist
"""
############################################################
# main imports
import sys
import os
import xbmcgui
import xbmc
import xbmcaddon
import traceback, threading

_A_ = xbmcaddon.Addon( __scriptID__ )
# language method
_L_ = _A_.getLocalizedString
# settings method
_S_ = _A_.getSetting


# set proper message
message = 32520

#pDialog = xbmcgui.DialogProgress()
#pDialog.create( __script__, _L_( message )  )
#pDialog.update( 0 )

from urllib import quote_plus
from random import shuffle, random

log_sep = "-"*70

downloaded_trailers = []

BASE_RESOURCE_PATH = xbmc.translatePath( os.path.join( _A_.getAddonInfo('path'), 'resources' ) )
sys.path.append( os.path.join( BASE_RESOURCE_PATH, "lib" ) )
from ce_playlist import _get_special_items
from ce_playlist import _get_queued_video_info
from download import download

def _get_trailers( items, mpaa, genre, movie ):
    # return if not user preference
    if ( not items ):
        return []
    # trailer settings, grab them here so we don't need another _S_() object
    settings = { "trailer_amt_db_file":  xbmc.translatePath( _S_( "trailer_amt_db_file" ) ),
                      "trailer_folder":  xbmc.translatePath( _S_( "trailer_folder" ) ),
                      "trailer_rating": _S_( "trailer_rating" ),
                 "trailer_limit_query": _S_( "trailer_limit_query" ) == "true",
                   "trailer_play_mode": int( _S_( "trailer_play_mode" ) ),
                     "trailer_hd_only": _S_( "trailer_hd_only" ) == "true",
                     "trailer_quality": int( _S_( "trailer_quality" ) ),
              "trailer_unwatched_only": _S_( "trailer_unwatched_only" ) == "true",
                 "trailer_newest_only": _S_( "trailer_newest_only" ) == "true",
                       "trailer_count": ( 0, 1, 2, 3, 4, 5, 10, )[ int( _S_( "trailer_count" ) ) ],
                     "trailer_scraper": ( "amt_database", "amt_current", "local", )[ int( _S_( "trailer_scraper" ) ) ]
               }
    # get the correct scraper
    exec "from resources.scrapers.%s import scraper as scraper" % ( settings[ "trailer_scraper" ], )
    Scraper = scraper.Main( mpaa, genre, settings, movie )
    # fetch trailers
    trailers = Scraper.fetch_trailers()
    # return results
    return trailers

class Main:
    # base paths
    BASE_CACHE_PATH = os.path.join( xbmc.translatePath( "special://profile" ), "Thumbnails", "Video" )
    BASE_CURRENT_SOURCE_PATH = os.path.join( xbmc.translatePath( "special://profile/addon_data/" ), os.path.basename( _A_.getAddonInfo('path') ) )
        
    def __init__( self ):
        self.download_trailers = downloaded_trailers
        self.number_of_features = int( _S_( "number_of_features") ) + 1
        self.playlistsize = xbmc.PlayList(xbmc.PLAYLIST_VIDEO).size()
        self._start()
        
    def _start( self ):
        try:
            # create the playlist
            self.playlist = xbmc.PlayList( xbmc.PLAYLIST_VIDEO )
            # Check to see if multiple features have been set in settings
            # if multiple features is greater than 1(not a single feature) 
            # add the intermission videos and audio files for the 2, third, etc movies
            if self.playlistsize > 1:
                movie_titles = ""
                for feature_count in range (1, self.playlistsize + 1):
                    movie_title = self.playlist[ feature_count - 1 ].getdescription()
                    xbmc.log( "[script.cinema.experience] - Feature #%-2d - %s" % ( feature_count, movie_title ), xbmc.LOGNOTICE )
                    movie_titles = movie_titles + movie_title + "<li>"
                movie_titles = movie_titles.rstrip("<li>")
                if _S_( "voxcommando" ) == "true":
                    xbmc.executehttpapi( "Broadcast(<b>CElaunch." + str(self.playlistsize ) + "<li>" + movie_titles + "</b>;33000)" )             
                if ( int( _S_( "intermission_video") ) > 0 or _S_( "intermission_audio") or _S_( "intermission_ratings") ):
                    mpaa, audio, genre, movie = self._add_intermission_videos()
            # otherwise just build for a single video
            else:
                # get the queued video info
                movie_title = self.playlist[ 0 ].getdescription()
                if _S_( "voxcommando" ) == "true":
                    xbmc.executehttpapi( "Broadcast(<b>CElaunch<li>" + movie_title + "</b>;33000)" )
                xbmc.log( "[script.cinema.experience] - Feature - %s" % movie_title, xbmc.LOGNOTICE )
                mpaa, audio, genre, movie = _get_queued_video_info()
            self._create_playlist( mpaa, audio, genre, movie)
            # play the trivia slide show
        except:
            traceback.print_exc()
             
    def _add_intermission_videos( self ):
        xbmc.log( "[script.cinema.experience] - Adding intermission Video(s)", xbmc.LOGNOTICE )
        count = 0
        index_count = 1
        for feature in range( 1, self.playlistsize ):
            mpaa, audio, genre, movie = _get_queued_video_info( index_count )
            #count = index_count
            # add intermission video
            if ( int( _S_( "intermission_video") ) > 0 ):
                xbmc.log( "[script.cinema.experience] - Inserting intermission Video(s): %s" % _S_( "intermission_video" ), xbmc.LOGNOTICE )
                xbmc.log( "[script.cinema.experience] -     playlist Position: %d" % index_count, xbmc.LOGNOTICE )
                p_size = xbmc.PlayList(xbmc.PLAYLIST_VIDEO).size()
                xbmc.log( "[script.cinema.experience] -     p_size: %d" % p_size, xbmc.LOGNOTICE )
                _get_special_items(    playlist=self.playlist,
                                          items=( 0, 1, 1, 2, 3, 4, 5, )[ int( _S_( "intermission_video" ) ) ], 
                                           path=( xbmc.translatePath( _S_( "intermission_video_file" ) ), xbmc.translatePath( _S_( "intermission_video_folder" ) ), )[ int( _S_( "intermission_video" ) ) > 1 ],
                                          genre=_L_( 32612 ),
                                         writer=_L_( 32612 ),
                                          index=index_count
                                   )
                if xbmc.PlayList(xbmc.PLAYLIST_VIDEO).size() > p_size and int( _S_( "intermission_video" ) ) > 1: 
                    index_count = index_count + int( _S_( "intermission_video" ) ) - 1
                elif xbmc.PlayList(xbmc.PLAYLIST_VIDEO).size() > p_size and int( _S_( "intermission_video" ) ) == 1:
                    index_count += int( _S_( "intermission_video" ) )
            # get rating video
            if ( _S_( "enable_ratings" ) ) == "true"  and (_S_( "intermission_ratings") ) == "true":
                xbmc.log( "[script.cinema.experience] - Inserting Intermission Rating Video",xbmc.LOGNOTICE )
                xbmc.log( "[script.cinema.experience] -     playlist Position: %d" % index_count, xbmc.LOGNOTICE )
                p_size = xbmc.PlayList(xbmc.PLAYLIST_VIDEO).size()
                xbmc.log( "[script.cinema.experience] -     p_size: %d" % p_size, xbmc.LOGNOTICE )
                _get_special_items(    playlist=self.playlist,
                                          items=1 * ( _S_( "rating_videos_folder" ) != "" ),
                                           path=xbmc.translatePath( _S_( "rating_videos_folder" ) ) + mpaa + ".avi",
                                          genre=_L_( 32603 ),
                                         writer=_L_( 32603 ),
                                         index = index_count
                                   )
                if xbmc.PlayList(xbmc.PLAYLIST_VIDEO).size() > p_size:
                    index_count += 1
            # get Dolby/DTS videos
            if ( _S_( "enable_audio" ) ) == "true"  and (_S_( "intermission_audio") ) == "true":
                xbmc.log( "[script.cinema.experience] - Inserting Intermission Audio Format Video",xbmc.LOGNOTICE )
                xbmc.log( "[script.cinema.experience] -     playlist Position: %d" % index_count, xbmc.LOGNOTICE )
                p_size = xbmc.PlayList(xbmc.PLAYLIST_VIDEO).size()
                xbmc.log( "[script.cinema.experience] -     p_size: %d" % p_size, xbmc.LOGNOTICE )
                _get_special_items(    playlist=self.playlist,
                                          items=1 * ( _S_( "audio_videos_folder" ) != "" ),
                                          path = xbmc.translatePath( _S_( "audio_videos_folder" ) ) + { "dca": "DTS", "ac3": "Dolby", "dtsma": "DTSHD-MA", "dtshd_ma": "DTSHD-MA", "a_truehd": "Dolby TrueHD", "truehd": "Dolby TrueHD" }.get( audio, "Other" ) + xbmc.translatePath( _S_( "audio_videos_folder" ) )[ -1 ],
                                          genre=_L_( 32606 ),
                                         writer=_L_( 32606 ),
                                         index = index_count
                                   )
                # Move to the next feature + 1 - if we insert 2 videos, the next feature is 3 away from the first video, then prepare for the next intro(+1)
                # count = feature * 3 + 1
                if xbmc.PlayList(xbmc.PLAYLIST_VIDEO).size() > p_size:
                    index_count += 1
            index_count += 1 
        # return info from first movie in playlist                                        
        mpaa, audio, genre, movie = _get_queued_video_info( 0 )
        return mpaa, audio, genre, movie
        
    def _create_playlist( self, mpaa, audio, genre, movie ):
        # TODO: try to get a local thumb for special videos?
        xbmc.log( "[script.cinema.experience] - Building Cinema Experience Playlist",xbmc.LOGNOTICE )
        # get Dolby/DTS videos
        xbmc.log( "[script.cinema.experience] - Adding Audio Format Video",xbmc.LOGNOTICE )
        if ( _S_( "enable_audio" ) ) == "true" and ( _S_( "audio_videos_folder" ) ):
                _get_special_items(    playlist=self.playlist,
                                          items=1 * ( _S_( "audio_videos_folder" ) != "" ),
                                           path=xbmc.translatePath( _S_( "audio_videos_folder" ) ) + { "dca": "DTS", "ac3": "Dolby", "dtsma": "DTSHD-MA", "dtshd_ma": "DTSHD-MA", "a_truehd": "Dolby TrueHD", "truehd": "Dolby TrueHD"  }.get( audio, "Other" ) + xbmc.translatePath( _S_( "audio_videos_folder" ) )[ -1 ],
                                          genre=_L_( 32606 ),
                                         writer=_L_( 32606 ),
                                          index=0
                                   )
        # Add Countdown video
        xbmc.log( "[script.cinema.experience] - Adding Count Down Videos: %s Videos" % _S_( "countdown_video" ),xbmc.LOGNOTICE )
        _get_special_items(    playlist=self.playlist,
                                                items=( 0, 1, 1, 2, 3, 4, 5, )[ int( _S_( "countdown_video" ) ) ], 
                                                path=( xbmc.translatePath( _S_( "countdown_video_file" ) ), xbmc.translatePath( _S_( "countdown_video_folder" ) ), )[ int( _S_( "countdown_video" ) ) > 1 ],
                                                genre=_L_( 32611 ),
                                                writer=_L_( 32611 ),
                                                index=0
                                            )
        # get rating video
        xbmc.log( "[script.cinema.experience] - Adding Ratings Video",xbmc.LOGNOTICE )
        if ( _S_( "enable_ratings" ) ) == "true" :
            _get_special_items(    playlist=self.playlist,
                                                    items=1 * ( _S_( "rating_videos_folder" ) != "" ), 
                                                    path=xbmc.translatePath( _S_( "rating_videos_folder" ) ) + mpaa + ".avi",
                                                    genre=_L_( 32603 ),
                                                    writer=_L_( 32603 ),
                                                    index=0
                                                )
        # get feature presentation intro videos
        xbmc.log( "[script.cinema.experience] - Adding Feature Presentation Intro Videos: %s Videos" % _S_( "fpv_intro" ),xbmc.LOGNOTICE )
        _get_special_items(    playlist=self.playlist,
                                                items=( 0, 1, 1, 2, 3, 4, 5, )[ int( _S_( "fpv_intro" ) ) ], 
                                                path=( xbmc.translatePath( _S_( "fpv_intro_file" ) ), xbmc.translatePath( _S_( "fpv_intro_folder" ) ), )[ int( _S_( "fpv_intro" ) ) > 1 ],
                                                genre=_L_( 32601 ),
                                                writer=_L_( 32601 ),
                                                index=0
                                            )
        # get trailers
        xbmc.log( "[script.cinema.experience] - Retriving Trailers: %s Trailers" % _S_( "trailer_count" ),xbmc.LOGNOTICE )
        if not int( _S_( "trailer_play_mode" ) ) == 1:
            trailers = _get_trailers(  items=( 0, 1, 2, 3, 4, 5, 10, )[ int( _S_( "trailer_count" ) ) ],
                                        mpaa=mpaa,
                                       genre=genre,
                                       movie=movie
                                    )
        else:
            trailers = self.download_trailers
        # get coming attractions outro videos
        xbmc.log( "[script.cinema.experience] - Adding Coming Attraction Video: %s Videos" % _S_( "cav_outro" ),xbmc.LOGNOTICE )
        _get_special_items(    playlist=self.playlist,
                                                items=( 0, 1, 1, 2, 3, 4, 5, )[ int( _S_( "cav_outro" ) ) ] * ( len( trailers ) > 0 ), 
                                                path=( xbmc.translatePath( _S_( "cav_outro_file" ) ), xbmc.translatePath( _S_( "cav_outro_folder" ) ), )[ int( _S_( "cav_outro" ) ) > 1 ],
                                                genre=_L_( 32608 ),
                                                writer=_L_( 32608 ),
                                                index=0
                                            )
        # enumerate through our list of trailers and add them to our playlist
        xbmc.log( "[script.cinema.experience] - Adding Trailers: %s Trailers" % len( trailers ),xbmc.LOGNOTICE )
        for trailer in trailers:
            # get trailers
            _get_special_items(    playlist=self.playlist,
                                       items=1,
                                        path=trailer[ 2 ],
                                       genre=trailer[ 9 ] or _L_( 32605 ),
                                       title=trailer[ 1 ],
                                   thumbnail=trailer[ 3 ],
                                        plot=trailer[ 4 ],
                                     runtime=trailer[ 5 ],
                                        mpaa=trailer[ 6 ],
                                release_date=trailer[ 7 ],
                                      studio=trailer[ 8 ] or _L_( 32604 ),
                                      writer= _L_( 32605 ),
                                    director=trailer[ 11 ],
                                       index=0
                              )
        # get coming attractions intro videos
        xbmc.log( "[script.cinema.experience] - Adding Coming Attraction Intro Videos: %s Videos" % _S_( "cav_intro" ),xbmc.LOGNOTICE )
        _get_special_items(    playlist=self.playlist,
                                  items=( 0, 1, 1, 2, 3, 4, 5, )[ int( _S_( "cav_intro" ) ) ] * ( len( trailers ) > 0 ), 
                                   path=( xbmc.translatePath( _S_( "cav_intro_file" ) ), xbmc.translatePath( _S_( "cav_intro_folder" ) ), )[ int( _S_( "cav_intro" ) ) > 1 ],
                                  genre=_L_( 32600 ),
                                 writer=_L_( 32600 ),
                                  index=0
                           )
        # get movie theater experience intro videos
        xbmc.log( "[script.cinema.experience] - Adding Movie Theatre Intro Videos: %s Videos" % _S_( "mte_intro" ),xbmc.LOGNOTICE )
        _get_special_items(    playlist=self.playlist,
                                  items=( 0, 1, 1, 2, 3, 4, 5, )[ int( _S_( "mte_intro" ) ) ], 
                                   path=( xbmc.translatePath( _S_( "mte_intro_file" ) ), xbmc.translatePath( _S_( "mte_intro_folder" ) ), )[ int( _S_( "mte_intro" ) ) > 1 ],
                                  genre=_L_( 32607 ),
                                 writer=_L_( 32607 ),
                                  index=0
                          )
        # get trivia outro video(s)
        xbmc.log( "[script.cinema.experience] - Adding Trivia Outro Videos: %s Videos" % _S_( "trivia_outro" ),xbmc.LOGNOTICE )
        _get_special_items(    playlist=self.playlist,
                                  items=( 0, 1, 1, 2, 3, 4, 5, )[ int( _S_( "trivia_outro" ) ) ], 
                                   path=( xbmc.translatePath( _S_( "trivia_outro_file" ) ), xbmc.translatePath( _S_( "trivia_outro_folder" ) ), )[ int( _S_( "trivia_outro" ) ) > 1 ],
                                  genre=_L_( 32610 ),
                                 writer=_L_( 32610 ),
                                   index=0
                             #media_type="video/picture"
                                                )
        # get feature presentation outro videos
        xbmc.log( "[script.cinema.experience] - Adding Feature Presentation Outro Videos: %s Videos" % _S_( "fpv_outro" ),xbmc.LOGNOTICE )
        _get_special_items(    playlist=self.playlist,
                                  items=( 0, 1, 1, 2, 3, 4, 5, )[ int( _S_( "fpv_outro" ) ) ], 
                                   path=( xbmc.translatePath( _S_( "fpv_outro_file" ) ), xbmc.translatePath( _S_( "fpv_outro_folder" ) ), )[ int( _S_( "fpv_outro" ) ) > 1 ],
                                  genre=_L_( 32602 ),
                                 writer=_L_( 32602 ),
                                            )
        # get movie theater experience outro videos
        xbmc.log( "[script.cinema.experience] - Adding Movie Theatre Outro Videos: %s Videos" % _S_( "mte_outro" ),xbmc.LOGNOTICE )
        _get_special_items(    playlist=self.playlist,
                                  items=( 0, 1, 1, 2, 3, 4, 5, )[ int( _S_( "mte_outro" ) ) ], 
                                   path=( xbmc.translatePath( _S_( "mte_outro_file" ) ), xbmc.translatePath( _S_( "mte_outro_folder" ) ), )[ int( _S_( "mte_outro" ) ) > 1 ],
                                  genre=_L_( 32607 ),
                                 writer=_L_( 32607 ),
                                            )
        xbmc.log( "[script.cinema.experience] - Playlist Size: %s" % xbmc.PlayList(xbmc.PLAYLIST_VIDEO).size(), xbmc.LOGNOTICE )
        return

class Downloader( threading.Thread ):
    def __init__( self ):
        threading.Thread.__init__( self )

            
    def run( self, *args, **kwargs ):
        self.mpaa  = kwargs[ "mpaa" ]
        self.genre = kwargs[ "genre" ]
        self.movie = ""
        downloaded_trailers =  self._download_trailers()
    
    def save_download_list( self, download_trailers ):
        xbmc.log( "[script.cinema.experience] - Saving List of Downloaded Trailers", xbmc.LOGNOTICE )
        try:
            # base path to watched file
            base_path = os.path.join( self.BASE_CURRENT_SOURCE_PATH, "downloaded_trailers.txt" )
            # if the path to the source file does not exist create it
            if ( not os.path.isdir( os.path.dirname( base_path ) ) ):
                os.makedirs( os.path.dirname( base_path ) )
            # open source path for writing
            file_object = open( base_path, "w" )
            for trailer in download_trailers:
                # write list
                file_object.write( repr( trailer[ 2 ] ) )
            # close file object
            file_object.close()
        except:
            pass
           
        
    def _download_trailers( self ):
        updated_trailers = []
        xbmc.log( "[script.cinema.experience] - Downloading Trailers: %s Trailers" % ( 0, 1, 2, 3, 4, 5, 10, )[ int( _S_( "trailer_count" ) ) ], xbmc.LOGNOTICE )
        trailers = _get_trailers(  items=( 0, 1, 2, 3, 4, 5, 10, )[ int( _S_( "trailer_count" ) ) ],
                                    mpaa=self.mpaa,
                                   genre=self.genre,
                                   movie=self.movie
                                   )
        for trailer in trailers:
            updated_trailer={}
            xbmc.log( "[script.cinema.experience] - Attempting To Download Trailer: %s" % trailer[ 1 ], xbmc.LOGNOTICE )
            filename, ext = os.path.splitext( os.path.basename( (trailer[ 2 ].split("|")[0] ).replace( "?","" ) ) )
            filename = filename + "-trailer" + ext
            file_path = os.path.join( _S_( "trailer_download_folder" ), filename ).replace( "\\\\", "\\" )
            # check to see if trailer is already downloaded
            if os.path.isfile( file_path ): 
                success = True
            else:
                success, destination = download( trailer[ 2 ], _S_( "trailer_download_folder" ), file_tag="-trailer" )
            if success:
                xbmc.log( "[script.cinema.experience] - Downloaded Trailer: %s" % trailer[ 1 ], xbmc.LOGNOTICE )
                updated_trailer[ 0 ] = trailer[ 0 ]
                updated_trailer[ 1 ] = trailer[ 1 ]
                updated_trailer[ 2 ] = destination
                updated_trailer[ 3 ] = trailer[ 3 ]
                updated_trailer[ 4 ] = trailer[ 4 ]
                updated_trailer[ 5 ] = trailer[ 5 ]
                updated_trailer[ 6 ] = trailer[ 6 ]
                updated_trailer[ 7 ] = trailer[ 7 ]
                updated_trailer[ 8 ] = trailer[ 8 ]
                updated_trailer[ 9 ] = trailer[ 9 ]
                updated_trailer[ 10 ] = trailer[ 10 ]
                updated_trailer[ 11 ] = trailer[ 11 ]
                self._create_nfo_file( updated_trailer, destination )
            else:
                xbmc.log( "[script.cinema.experience] - Failed to Download Trailer: %s" % trailer[ 1 ], xbmc.LOGNOTICE )
                updated_trailer=[]
            updated_trailers += [ updated_trailer ]
        return updated_trailers
    
    def _create_nfo_file( self, trailer, trailer_nfopath ):
        '''
            path=trailer[ 2 ],
            genre=trailer[ 9 ],
            title=trailer[ 1 ],
            thumbnail=trailer[ 3 ],
            plot=trailer[ 4 ],
            runtime=trailer[ 5 ],
            mpaa=trailer[ 6 ],
            release_date=trailer[ 7 ],
            studio=trailer[ 8 ],
            director=trailer[ 11 ]
        '''
        xbmc.log( "[script.cinema.experience] - Creating Trailer NFO file", xbmc.LOGNOTICE )
        # set quality, we do this since not all resolutions have trailers
        quality = ( "Standard", "480p", "720p", "1080p" )[ _S_( "trailer_quality" ) ]
        # set movie info
        nfoSource = """<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<movieinfo>
    <title>%s</title>
    <quality>%s</quality>
    <runtime>%s</runtime>
    <releasedate>%s</releasedate>
    <mpaa>%s</mpaa>
    <genre>%s</genre>
    <studio>%s</studio>
    <director>%s</director>
    <cast>%s</cast>
    <plot>%s</plot>
    <thumb>%s</thumb>
</movieinfo>
""" % ( trailer[ 1 ], quality, trailer[ 5 ], trailer[ 7 ], trailer[ 6 ], trailer[ 9 ], trailer[ 8 ], trailer[ 11 ], "", trailer[ 4 ], trailer[ 3 ] )
        # save nfo file
        return self._save_nfo_file( nfoSource, trailer_nfopath )

    def _save_nfo_file( self, nfoSource, trailer_nfopath ):
        xbmc.log( "[script.cinema.experience] - Saving Trailer NFO file", xbmc.LOGNOTICE )
        destination = os.path.splitext( trailer_nfopath )[0] + ".nfo"
        try:
            # open source path for writing
            file_object = open( destination.encode( "utf-8" ), "w" )
            # write xmlSource
            file_object.write( nfoSource.encode( "utf-8" ) )
            # close file object
            file_object.close()
            # return successful
            return True
        except Exception, e:
            # oops, notify user what error occurred
            xbmc.log( "[script.cinema.experience] - %s" % str( e ), xbmc.LOGERROR )
            # return failed
            return False